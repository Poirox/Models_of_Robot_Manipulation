#!/usr/bin/python
#  Python inverse kinematic equations for Wrist

#  This test performs the following:
#
#  1) Generate a reachable 4x4 pose
#  2) run the generated IK Python code for "Wrist" robot
#  3) take resulting list of joint-solutions and put them back into
#          forward kinematics
#  4) compare the generated 4x4 matrices to the original pose
#
#  Running instructions:
#
#   > cd IKBT/
#   > pyton -m tests.Wrist_IK_loop_test
#
#   final results for each solution are error -- should be very small
#
#
import numpy as np
from math import sqrt
from math import atan2
from math import cos
from math import sin
from math import asin
from math import acos

from ikbtbasics.pykinsym import *
from ikbtfunctions.helperfunctions import *
from ikbtbasics.kin_cl import *
from ikbtbasics.ik_classes import *     # special classes for Inverse kinematics in sympy
from ikbtfunctions.ik_robots import *


pi = np.pi




###############################################
#
#


# Code to solve the unknowns
def ikin_[ROBOTNAME](T):              # don't keep the [] brackets
    if(T.shape != (4,4)):
        print "bad input to "+funcname
        quit()
#define the input vars
    r_11 = T[0,0]
    r_12 = T[0,1]
    r_13 = T[0,2]
    r_21 = T[1,0]
    r_22 = T[1,1]
    r_23 = T[1,2]
    r_31 = T[2,0]
    r_32 = T[2,1]
    r_33 = T[2,2]
    Px = T[0,3]
    Py = T[1,3]
    Pz = T[2,3]

#  put generated solution code here (eliminate duplication with template code)



    solution_list = []
    #(note trailing commas allowed in python
    solution_list.append( [ each solution goes here ] )
    #(note trailing commas allowed in python
    solution_list.append( [  each solution goes here ] )
    
    ...  continue appending ...
    
    if(solvable_pose):
        return(solution_list)
    else:
        return(False)


#
###############################################


#
#    TEST CODE
#
if __name__ == "__main__":

    robot = '[ROBOTNAME]'
    #   Get the robot model
    [dh, vv, params, pvals, unknowns] = robot_params(robot)  # see ikbtfunctions/ik_robots.py

    #
    #     Set up robot equations for further solution by BT
    #
    #   Check for a pickle file of pre-computed Mech object. If the pickle
    #       file is not there, compute the kinematic equations
    #       if the pickle file is there it has pre-computed kinematic eqns to save time
    #
    testing = False
    [M, R, unknowns] = kinematics_pickle(robot, dh, params, pvals, vv, unknowns, testing)
    print 'GOT HERE: robot name: ', R.name

    R.name = robot
    R.params = params

    ##   check the pickle in case DH params were changed
    dhp = M.DH
    check_the_pickle(dhp, dh)   # check stored robot matches current DH params

    #  4x4 transform based on known joint angles:

    deg = sp.pi/180.0 
 
###  Generate Test data  
#  4x4 transforms generated by known joint angles
     ... your code here ...

    pose1 = {th_1: xxx, th_2: xxxx , th_3: xxxx,  ..... }  # edit this to match your arm 

    T1 = forward_kinematics_N(M, pose, M.pvals)   # one of our numerical fcns in ikbtbasics/kin_cl.py 
           # where "M" is the robot model (see above) and pose is your set of joint angles

    print '\n\nDesired T06:'
    print(T1)
    
    # now do the Inverse Kinematics function defined above
    sol_list = ikin_[ROBOTNAME](T1)

    i = 0
    for sol in sol_list:
        print ''
        print 'Solution ', i
        i+=1 
        print ('{0:8.2f}  '.format(sol[0]*todeg)),    # th1    ... etc for all your joint vars

#########3 try to plug back into FK model

    i=0
    # for each solution, compare FK(sol) with T01
    print '\n\nMax error for each Solution: '
    for sol in sol_list:
        pose = {th_1 : sol[1], th_2 : sol[2], d_3 : sol[0], th_4:sol[3], th_5:sol[5], th_6:sol[6]} # all joints included
        T2 = forward_kinematics_N(M, pose, M.pvals)
        maxe = -9999999.99
        #print '- - - - - '
        #sp.pprint (T2-T1)
        #print '- - - - - '
        for k in [0,1,2]:
            for j in [0,1,2,3]:
                e = T1[k,j]-T2[k,j]
                #print '<<',e,'>>'
                if np.abs(e) > maxe:
                    maxe = np.abs(e)
        print 'Solution ',i,': ', maxe
        i += 1
